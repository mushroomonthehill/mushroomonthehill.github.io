<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CyberDefense：惡意源碼配對戰</title>
    
    <!-- ★★★ 網站小圖示 (Favicon) ★★★ -->
    <link rel="icon" href="img/siteicon.png" type="image/png">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: VT323 for pixel/retro look -->
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --neon-green: #00ff41;
            --dark-bg: #0d0221;
            --term-black: #000000;
            --win-95-gray: #c0c0c0;
            --danger-red: #ff003c;
            --info-blue: #00d0ff;
            --warn-yellow: #ffcc00;
            --elite-purple: #d600ff;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: var(--dark-bg);
            color: var(--neon-green);
            overflow-y: auto;
            overflow-x: hidden;
            background-image: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            text-shadow: 2px 2px var(--term-black);
            touch-action: manipulation; 
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Retro Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: var(--neon-green); border: 1px solid #000; }

        /* Glitch Effect */
        .glitch-text {
            position: relative;
            animation: glitch-skew 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) both infinite;
        }
        @keyframes glitch-skew {
            0% { transform: skew(0deg); }
            20% { transform: skew(-2deg); }
            40% { transform: skew(2deg); }
            60% { transform: skew(-1deg); }
            80% { transform: skew(1deg); }
            100% { transform: skew(0deg); }
        }

        /* Card Styling */
        .game-card {
            perspective: 1000px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            height: 100%; 
            min-height: 90px; 
        }
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border: 2px solid var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
            background: #000;
        }
        .game-card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .game-card.matched .card-inner {
            border-color: gold;
            box-shadow: 0 0 15px gold;
            animation: pulse-gold 1s infinite;
        }
        
        @keyframes pulse-gold {
            0% { box-shadow: 0 0 15px gold; }
            50% { box-shadow: 0 0 25px gold; }
            100% { box-shadow: 0 0 15px gold; }
        }

        /* Knowledge Card specific style */
        .knowledge-mode .card-inner {
            border-color: var(--info-blue);
            box-shadow: 0 0 10px var(--info-blue);
        }
        .knowledge-mode .card-back {
            background-color: var(--info-blue);
            color: #000;
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2px;
            box-sizing: border-box;
        }
        .card-front {
            background-color: #0a0a0a;
            color: var(--neon-green);
        }
        .knowledge-mode .card-front {
            color: var(--info-blue);
        }

        .card-back {
            background-color: var(--neon-green);
            color: #000;
            transform: rotateY(180deg);
            font-size: 0.8rem; 
            line-height: 1.1;
            font-weight: bold;
            padding: 4px;
            overflow: hidden;
            text-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 768px) {
            .card-back {
                font-size: 1rem;
                padding: 6px;
            }
            .game-card {
                min-height: 120px;
            }
        }

        /* Shake Animation */
        .shake {
            animation: shake 0.5s;
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            25% { transform: translate(-3px, 0px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            75% { transform: translate(3px, 1px) rotate(-1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* Win/Lose/Alert Screens */
        .overlay-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem; 
        }

        /* Canvas for Fireworks */
        #fireworks-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40;
        }

        /* Retro Button */
        .retro-btn {
            background: #000;
            border: 2px solid var(--neon-green);
            color: var(--neon-green);
            padding: 8px 16px; 
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 60; 
            position: relative;
        }
        .retro-btn.danger {
            border-color: var(--danger-red);
            color: var(--danger-red);
        }
        .retro-btn.danger:hover {
            background: var(--danger-red);
            color: #fff;
            box-shadow: 0 0 15px var(--danger-red);
        }
        .retro-btn.elite {
            border-color: var(--elite-purple);
            color: var(--elite-purple);
        }
        .retro-btn.elite:hover {
            background: var(--elite-purple);
            color: #fff;
            box-shadow: 0 0 15px var(--elite-purple);
        }

        @media (min-width: 768px) {
            .retro-btn { font-size: 1.5rem; padding: 10px 20px; }
        }

        .retro-btn:hover, .retro-btn:active {
            background: var(--neon-green);
            color: #000;
            box-shadow: 0 0 15px var(--neon-green);
        }
        
        .info-btn {
            border-color: var(--info-blue);
            color: var(--info-blue);
        }
        .info-btn:hover, .info-btn:active {
            background: var(--info-blue);
            color: #000;
            box-shadow: 0 0 15px var(--info-blue);
        }

        /* BSOD Style */
        .bsod {
            background-color: #8B0000;
            color: #fff;
            text-shadow: none;
            font-family: 'Courier New', Courier, monospace;
        }

        /* Timer Bar */
        .progress-container {
            width: 100%;
            height: 15px;
            border: 2px solid var(--neon-green);
            margin-top: 10px;
        }
        @media (min-width: 768px) {
            .progress-container { height: 20px; }
        }

        .progress-bar {
            height: 100%;
            background-color: var(--neon-green);
            width: 100%;
            transition: width 1s linear, background-color 0.3s;
        }
        
        .low-time {
            background-color: var(--danger-red) !important;
            box-shadow: 0 0 15px var(--danger-red);
            animation: flash-alert 0.5s infinite alternate;
        }

        .memorize-mode {
            background-color: var(--warn-yellow) !important;
            box-shadow: 0 0 10px var(--warn-yellow);
        }
        
        @keyframes flash-alert {
            from { opacity: 1; box-shadow: 0 0 15px var(--danger-red); }
            to { opacity: 0.6; box-shadow: 0 0 5px var(--danger-red); }
        }

        /* CRT Scanline Overlay */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            z-index: 9999;
            pointer-events: none;
        }
        
        /* Layout Helpers */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 72rem; /* max-w-6xl */
            margin: 0 auto;
        }
        
        .footer {
            width: 100%;
            padding: 1rem;
            text-align: center;
            color: #6b7280;
            background-color: rgba(0,0,0,0.9);
            border-top: 1px solid #1f2937;
            font-size: 0.875rem;
            z-index: 45;
        }
        
        /* --- Optimized Win Screen for Mobile --- */
        .win-content {
            width: 100%;
            max-width: 28rem;
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <!-- Background Audio -->
    <audio id="bgm" loop>
        <source src="https://freemusicarchive.org/track/visager-title-theme/download" type="audio/mpeg">
    </audio>

    <!-- START SCREEN (Basic Mode) -->
    <div id="start-screen" class="flex flex-col items-center justify-center min-h-screen w-full bg-black z-40 px-4 py-8">
        <h1 class="text-3xl md:text-5xl mb-6 glitch-text text-center whitespace-nowrap" style="color: var(--neon-green);">
            <i class="fas fa-shield-virus"></i> 惡意源碼配對戰
        </h1>
        <div class="border-2 border-green-500 p-6 md:p-8 bg-gray-900 max-w-md w-full text-center shadow-[0_0_20px_rgba(0,255,65,0.5)]">
            <div class="flex justify-center items-center mb-2">
                <span class="text-yellow-400 text-xl">難度: ★★★ (初階任務)</span>
            </div>
            
            <p class="text-xl md:text-2xl mb-4">請輸入探員代號：</p>
            <input type="text" id="player-name-input" class="w-full bg-black border border-green-500 text-green-500 p-2 text-xl md:text-2xl text-center mb-6 focus:outline-none focus:shadow-[0_0_10px_#00ff41]" placeholder="PLAYER_1" maxlength="10">
            
            <div class="text-left text-lg md:text-xl mb-6 space-y-2 border-t border-gray-700 pt-4">
                <p><i class="fas fa-book-reader text-blue-400"></i> 知識庫: 60 秒</p>
                <p><i class="fas fa-eye text-yellow-400"></i> 記憶階段: <span class="text-white">40 秒</span> (自動展示)</p>
                <p><i class="fas fa-clock"></i> 挑戰限時: 120 秒</p>
                <p><i class="fas fa-minus-circle text-gray-400"></i> 錯誤不扣秒</p>
            </div>

            <button onclick="initializeGame('basic')" class="retro-btn w-full animate-pulse">
                > 啟動初階任務
            </button>
        </div>
    </div>

    <!-- ADVANCED MODE INTRO ALERT -->
    <div id="advanced-intro-screen" class="overlay-screen bg-black/95 backdrop-blur-sm px-4">
        <div class="border-4 border-purple-500 p-6 md:p-8 bg-gray-900 text-center max-w-lg w-full shadow-[0_0_50px_rgba(214,0,255,0.3)]">
            <!-- Force single line with whitespace-nowrap and smaller text -->
            <h2 class="text-2xl md:text-4xl mb-4 text-purple-400 glitch-text whitespace-nowrap font-bold">⚠ 警告：魔王級關卡</h2>
            <div class="text-yellow-400 text-xl md:text-2xl mb-4 md:mb-6">難度: ★★★★★</div>
            
            <div class="text-left text-base md:text-xl mb-6 md:mb-8 space-y-3 bg-black/50 p-4 border border-purple-800">
                <p class="text-red-400 font-bold"><i class="fas fa-exclamation-triangle"></i> 記憶階段變更：</p>
                <p>卡牌將<span class="text-yellow-300">維持覆蓋</span>狀態，請於30秒內<span class="text-yellow-300">手動點擊翻閱</span>記憶位置！</p>
                <hr class="border-purple-900 my-2">
                <p><i class="fas fa-clock"></i> 挑戰限時: 150 秒</p>
                <p><i class="fas fa-check text-green-400"></i> 正確: +5 秒</p>
                <p><i class="fas fa-times text-red-500"></i> 錯誤: -5 秒</p>
            </div>

            <button onclick="startAdvancedMemorize()" class="retro-btn elite w-full animate-pulse">
                > 接受挑戰 (START)
            </button>
        </div>
    </div>

    <!-- KNOWLEDGE REVIEW SCREEN -->
    <div id="knowledge-screen" class="hidden main-content p-2 md:p-4">
        <div class="flex justify-between items-center border-b-2 border-blue-500 pb-2 mb-4 flex-shrink-0">
            <div>
                <h2 class="text-xl md:text-3xl text-blue-400">資料庫載入中... <span class="text-xs md:text-sm text-white blink">READING...</span></h2>
                <div class="text-sm md:text-lg text-gray-400">點擊卡片翻閱特性</div>
            </div>
            <div class="text-right flex items-center gap-2 md:gap-4">
                <div class="text-2xl md:text-4xl text-blue-400 font-bold" id="knowledge-timer">60</div>
                <button onclick="startPreGamePhase()" class="retro-btn info-btn text-sm px-2 py-1 md:px-4 md:py-2">
                    > 開始挑戰
                </button>
            </div>
        </div>
        
        <!-- Knowledge Grid -->
        <div id="knowledge-grid" class="grid grid-cols-4 gap-2 md:gap-4">
            <!-- Info Cards injected here -->
        </div>
    </div>

    <!-- GAME SCREEN -->
    <div id="game-screen" class="hidden main-content p-2 md:p-4">
        <!-- Header Stats -->
        <div class="flex justify-between items-end border-b-2 border-green-500 pb-2 mb-2 md:mb-4 flex-shrink-0">
            <div>
                <h2 class="text-xl md:text-3xl">探員: <span id="display-player-name" class="text-white">UNKNOWN</span></h2>
                <div class="text-sm md:text-xl text-gray-400" id="game-status-text">STATUS: MEMORIZE</div>
            </div>
            <div class="text-right">
                <div class="text-3xl md:text-5xl font-bold" id="timer-display">30</div>
                <div class="text-xs md:text-sm">SECONDS</div>
            </div>
        </div>
        
        <!-- Timer Bar -->
        <div class="progress-container mb-4 flex-shrink-0">
            <div id="time-bar" class="progress-bar memorize-mode"></div>
        </div>

        <!-- Game Grid -->
        <div id="game-grid" class="grid grid-cols-4 gap-2 md:gap-4 pb-4">
            <!-- Game Cards injected here -->
        </div>
    </div>

    <!-- WIN SCREEN (COMPACT) -->
    <div id="win-screen" class="overlay-screen bg-black/90 backdrop-blur-sm">
        <canvas id="fireworks-canvas"></canvas>
        <!-- Compact Win Container -->
        <div class="win-content border-4 border-green-500 p-4 bg-gray-900 text-center shadow-[0_0_50px_rgba(0,255,65,0.3)] z-50 relative flex flex-col items-center">
            <h2 class="text-3xl md:text-4xl mb-1 text-yellow-400 glitch-text">任務完成!</h2>
            <h3 class="text-lg md:text-xl mb-4 text-white">MISSION ACCOMPLISHED</h3>
            
            <!-- Compact Grid -->
            <div class="grid grid-cols-2 gap-x-2 gap-y-1 text-base md:text-lg text-left mb-4 border border-gray-700 p-3 bg-black/50 w-full">
                <div class="text-gray-400">探員姓名:</div><div id="win-name" class="text-right text-white truncate"></div>
                <div class="text-gray-400">難度:</div><div id="win-mode" class="text-right text-blue-400"></div>
                <div class="text-gray-400">剩餘時間:</div><div id="win-time" class="text-right text-white"></div>
                <div class="text-gray-400">錯誤次數:</div><div id="win-errors" class="text-right text-red-400"></div>
            </div>

            <div class="w-full border-t border-gray-600 my-2"></div>
            
            <div class="flex items-center gap-3 mb-4">
                <div class="text-xl md:text-2xl font-bold text-yellow-300">獲得稱號:</div>
                <!-- Rank and Title in one block -->
                <div id="win-rank" class="text-right font-bold glitch-text leading-tight flex flex-col items-end">
                    <!-- Rank injected here -->
                </div>
            </div>

            <div id="win-buttons" class="flex flex-col gap-2 w-full">
                <!-- Buttons injected dynamically -->
            </div>
        </div>
    </div>

    <!-- LOSE SCREEN -->
    <div id="lose-screen" class="overlay-screen bsod px-4">
        <div class="text-center p-4 md:p-8 max-w-4xl w-full">
            <div class="text-5xl md:text-9xl mb-4"><i class="fas fa-skull-crossbones"></i></div>
            <h1 class="text-3xl md:text-6xl md:text-8xl mb-8 font-bold">FATAL ERROR</h1>
            
            <div class="text-base md:text-3xl text-left font-mono bg-black/20 p-4 md:p-6 mb-8">
                <p>System compromised.</p>
                <p class="mt-4 text-yellow-300">AGENT: <span id="lose-name"></span></p>
                <p>FAILED TO SECURE NETWORK.</p>
                <p>GAME OVER.</p>
            </div>

            <button onclick="retryGame()" class="border-2 border-white text-white px-4 py-2 md:px-8 md:py-4 text-xl md:text-2xl hover:bg-white hover:text-red-900 transition font-mono w-full md:w-auto">
                > SYSTEM REBOOT
            </button>
        </div>
    </div>

    <!-- COPYRIGHT FOOTER -->
    <div class="footer">
        <p>© CL IT Classroom. All rights reserved.</p>
        <p class="mt-1">遊戲構思: CL IT Classroom | 遊戲生成: Google Gemini</p>
        <div class="mt-2">
            <a href="https://github.com/mushroomonthehill" target="_blank" class="text-gray-500 hover:text-white transition-colors">
                <i class="fab fa-github text-2xl"></i>
            </a>
        </div>
    </div>

    <script>
        // --- Game Data ---
        const gameData = [
            { id: 1, type: 'term', text: '病毒 (Virus)', matchId: 'virus_desc', icon: 'fa-virus' },
            { id: 'virus_desc', type: 'desc', text: '像感冒附著檔案，需「人為開啟」擴散。會刪除檔案。', matchId: 1 },
            { id: 2, type: 'term', text: '蠕蟲 (Worm)', matchId: 'worm_desc', icon: 'fa-locust' },
            { id: 'worm_desc', type: 'desc', text: '不需附著檔案，利用網路漏洞「自動」擴散。造成網路塞車。', matchId: 2 },
            { id: 3, type: 'term', text: '木馬 (Trojan)', matchId: 'trojan_desc', icon: 'fa-horse-head' },
            { id: 'trojan_desc', type: 'desc', text: '偽裝成好用軟體。目的是「開後門」讓駭客偷資料。', matchId: 3 },
            { id: 4, type: 'term', text: '勒索軟體', matchId: 'ransom_desc', icon: 'fa-file-contract' },
            { id: 'ransom_desc', type: 'desc', text: '將檔案「加密」鎖起來，要求付贖金才解鎖。例:WannaCry。', matchId: 4 },
            { id: 5, type: 'term', text: '間諜軟體', matchId: 'spy_desc', icon: 'fa-user-secret' },
            { id: 'spy_desc', type: 'desc', text: '偷偷監視你。如「鍵盤側錄」記錄你的密碼。', matchId: 5 },
            { id: 6, type: 'term', text: '釣魚網站', matchId: 'phish_desc', icon: 'fa-fish' },
            { id: 'phish_desc', type: 'desc', text: '偽裝成登入頁面(如Google)，騙你輸入帳號密碼。', matchId: 6 },
            { id: 7, type: 'term', text: '零日攻擊', matchId: 'zero_desc', icon: 'fa-bomb' },
            { id: 'zero_desc', type: 'desc', text: '利用尚未修補的漏洞(Zero-day)攻擊，防毒軟體來不及擋。', matchId: 7 },
            { id: 8, type: 'term', text: 'WannaCry', matchId: 'wannacry_desc', icon: 'fa-sad-cry' },
            { id: 'wannacry_desc', type: 'desc', text: '著名勒索軟體。造成全球電腦被鎖住。', matchId: 8 }
        ];

        // --- Global Variables ---
        let currentDifficulty = 'basic'; 
        let cards = [];
        let hasFlippedCard = false;
        let lockBoard = true; 
        let firstCard, secondCard;
        let timeLeft = 0;
        let memorizeTimeLeft = 30;
        let knowledgeTimeLeft = 60;
        let timerId;
        let memorizeTimerId;
        let knowledgeTimerId;
        let matchesFound = 0;
        let totalPairs = 8;
        let playerName = "Unknown";
        let errorCount = 0;
        let audioCtx;
        let fireworksInterval;
        let isMemorizePhase = false;

        // --- Sound Logic (Super Enhanced) ---
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
        }

        function playSound(type) {
            if (!audioCtx) initAudio();
            const now = audioCtx.currentTime;

            if (type === 'flip') {
                playOscillator('sine', 400, 600, 0.1, now);
            } else if (type === 'match') {
                playOscillator('square', 600, 1200, 0.3, now);
            } else if (type === 'error') {
                playOscillator('sawtooth', 150, 100, 0.3, now);
            } else if (type === 'warning') {
                playOscillator('square', 880, 880, 0.1, now, 0.1);
            } else if (type === 'victory') {
                // Extended Victory Fanfare (RPG Style) ~5 seconds
                // Main Melody
                const melody = [
                    // Intro Triplet
                    {f: 523.25, d: 0.15, t: 0.0}, // C5
                    {f: 523.25, d: 0.15, t: 0.15}, // C5
                    {f: 523.25, d: 0.15, t: 0.30}, // C5
                    {f: 523.25, d: 0.4, t: 0.45}, // C5 (Hold)
                    
                    // Fanfare Rise
                    {f: 415.30, d: 0.3, t: 0.9}, // G#4
                    {f: 466.16, d: 0.3, t: 1.2}, // A#4
                    {f: 523.25, d: 0.2, t: 1.5}, // C5
                    {f: 466.16, d: 0.2, t: 1.7}, // A#4
                    {f: 523.25, d: 1.5, t: 1.9}, // C5 (Grand Finish)
                ];

                // Harmony / Arpeggio
                const harmony = [
                    {f: 261.63, d: 0.5, t: 0.0}, // C4
                    {f: 311.13, d: 0.5, t: 0.9}, // D#4
                    {f: 392.00, d: 0.5, t: 1.4}, // G4
                    {f: 523.25, d: 2.0, t: 1.9}  // C5
                ];

                melody.forEach(n => playTone(n.f, 'square', now + n.t, n.d, 0.1));
                harmony.forEach(n => playTone(n.f, 'triangle', now + n.t, n.d, 0.1));

                // Sparkle / Effect at end
                setTimeout(() => {
                    playOscillator('sine', 800, 1200, 0.5, audioCtx.currentTime);
                    playOscillator('sine', 1200, 2000, 0.5, audioCtx.currentTime + 0.1);
                }, 2000);

            } else if (type === 'gameover') {
                playOscillator('sawtooth', 100, 50, 1.0, now);
            }
        }

        function playOscillator(type, startFreq, endFreq, duration, startTime, volDuration = null) {
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(startFreq, startTime);
            if(startFreq !== endFreq) osc.frequency.exponentialRampToValueAtTime(endFreq, startTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + (volDuration || duration));
            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        function playTone(freq, type, time, duration, vol) {
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.type = type;
            osc.frequency.value = freq;
            
            // Attack
            gainNode.gain.setValueAtTime(0, time);
            gainNode.gain.linearRampToValueAtTime(vol, time + 0.05);
            // Decay/Sustain
            gainNode.gain.linearRampToValueAtTime(vol * 0.8, time + duration * 0.8);
            // Release
            gainNode.gain.linearRampToValueAtTime(0, time + duration);
            
            osc.start(time);
            osc.stop(time + duration);
        }

        // --- Game Initialization ---
        function initializeGame(difficulty) {
            currentDifficulty = difficulty;
            const nameInput = document.getElementById('player-name-input').value;
            if (playerName === "Unknown") { 
                playerName = nameInput.trim() || "PLAYER_1";
            }
            document.getElementById('display-player-name').innerText = playerName;

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none'; 
            document.getElementById('game-screen').style.display = 'none'; 
            
            document.getElementById('knowledge-screen').style.display = 'flex';
            window.scrollTo(0, 0); 
            
            const bgm = document.getElementById('bgm');
            bgm.volume = 0.2;
            bgm.play().catch(e => console.log("Audio autoplay blocked"));

            createKnowledgeBoard();
            knowledgeTimeLeft = 60;
            document.getElementById('knowledge-timer').innerText = knowledgeTimeLeft;
            
            clearInterval(knowledgeTimerId);
            knowledgeTimerId = setInterval(() => {
                knowledgeTimeLeft--;
                document.getElementById('knowledge-timer').innerText = knowledgeTimeLeft;
                if(knowledgeTimeLeft <= 0) {
                    startPreGamePhase();
                }
            }, 1000);
        }

        function createKnowledgeBoard() {
            const grid = document.getElementById('knowledge-grid');
            grid.innerHTML = '';
            const terms = gameData.filter(item => item.type === 'term');
            terms.forEach(termItem => {
                const descItem = gameData.find(d => d.id === termItem.matchId);
                const card = document.createElement('div');
                card.classList.add('game-card', 'knowledge-mode'); 
                card.innerHTML = `
                    <div class="card-inner">
                        <div class="card-front">
                            <div class="text-3xl md:text-4xl mb-1 md:mb-2"><i class="fas ${termItem.icon}"></i></div>
                            <div class="text-lg md:text-xl">${termItem.text}</div>
                            <div class="text-xs md:text-sm mt-1 md:mt-2 text-gray-500">(點擊翻面)</div>
                        </div>
                        <div class="card-back">
                            <div class="leading-tight">${descItem.text}</div>
                        </div>
                    </div>
                `;
                card.addEventListener('click', function() {
                    this.classList.toggle('flipped');
                    playSound('flip');
                });
                grid.appendChild(card);
            });
        }

        // --- Pre-Game Routing ---
        function startPreGamePhase() {
            clearInterval(knowledgeTimerId);
            document.getElementById('knowledge-screen').style.display = 'none';
            window.scrollTo(0, 0);

            if (currentDifficulty === 'advanced') {
                document.getElementById('advanced-intro-screen').style.display = 'flex';
            } else {
                startMemorizePhase();
            }
        }

        function startAdvancedMemorize() {
            document.getElementById('advanced-intro-screen').style.display = 'none';
            startMemorizePhase();
        }

        // --- Memorize Phase ---
        function startMemorizePhase() {
            document.getElementById('game-screen').style.display = 'flex';
            window.scrollTo(0, 0); 
            
            // Basic Mode uses 40s for memorize
            memorizeTimeLeft = currentDifficulty === 'basic' ? 40 : 30;
            const initialMaxTime = memorizeTimeLeft;
            
            timeLeft = currentDifficulty === 'basic' ? 120 : 150;
            matchesFound = 0;
            errorCount = 0;
            hasFlippedCard = false;
            firstCard = null;
            secondCard = null;
            
            isMemorizePhase = true;

            updateTimerDisplay(memorizeTimeLeft, initialMaxTime, true);
            document.getElementById('game-status-text').innerText = "STATUS: MEMORIZE POSITIONS";
            document.getElementById('game-status-text').style.color = 'yellow';

            document.getElementById('game-grid').innerHTML = '';

            if (currentDifficulty === 'basic') {
                lockBoard = true; 
                createGameBoard(true); // All Face Up
            } else {
                lockBoard = false; 
                createGameBoard(false); // All Face Down
            }

            clearInterval(memorizeTimerId);
            memorizeTimerId = setInterval(() => {
                memorizeTimeLeft--;
                updateTimerDisplay(memorizeTimeLeft, initialMaxTime, true);
                if (memorizeTimeLeft <= 0) {
                    clearInterval(memorizeTimerId);
                    startMainGamePhase();
                }
            }, 1000);
        }

        function startMainGamePhase() {
            isMemorizePhase = false;
            lockBoard = false; 
            
            const allCards = document.querySelectorAll('#game-grid .game-card');
            allCards.forEach(card => {
                card.classList.remove('flipped');
            });
            
            hasFlippedCard = false;
            firstCard = null;
            secondCard = null;

            document.getElementById('game-status-text').innerText = "STATUS: SECURITY ALERT (MATCHING)";
            document.getElementById('game-status-text').style.color = '#00ff41';
            
            let maxTime = currentDifficulty === 'basic' ? 120 : 150;
            updateTimerDisplay(timeLeft, maxTime, false);
            startGameTimer(maxTime);
        }

        function startGameTimer(maxTime) {
            clearInterval(timerId);
            timerId = setInterval(() => {
                timeLeft--;
                updateTimerDisplay(timeLeft, maxTime, false);
                
                if (timeLeft <= 30 && timeLeft > 0) {
                     playSound('warning');
                }

                if (timeLeft <= 0) {
                    gameOver(false);
                }
            }, 1000);
        }

        function updateTimerDisplay(time, maxTime, isMemorize) {
            const timerEl = document.getElementById('timer-display');
            const bar = document.getElementById('time-bar');
            timerEl.innerText = time;
            const percent = (time / maxTime) * 100;
            bar.style.width = `${percent}%`;
            
            if (isMemorize) {
                bar.classList.add('memorize-mode');
                bar.classList.remove('low-time');
                timerEl.style.color = 'yellow';
            } else {
                bar.classList.remove('memorize-mode');
                if (time <= 30) {
                    bar.classList.add('low-time');
                    timerEl.style.color = 'red';
                } else {
                    bar.classList.remove('low-time');
                    timerEl.style.color = 'white';
                }
            }
        }

        function createGameBoard(initiallyFlipped) {
            const grid = document.getElementById('game-grid');
            grid.innerHTML = ''; 
            cards = [...gameData]; 
            cards.sort(() => 0.5 - Math.random());

            cards.forEach(item => {
                const card = document.createElement('div');
                card.classList.add('game-card');
                if (initiallyFlipped) card.classList.add('flipped');
                
                card.dataset.id = item.id;
                card.dataset.matchId = item.matchId;
                
                let frontContent = (item.type === 'term') ? 
                    `<div class="text-3xl md:text-4xl mb-1 md:mb-2"><i class="fas ${item.icon}"></i></div><div class="text-lg md:text-xl">${item.text}</div>` : 
                    `<div class="leading-tight">${item.text}</div>`;

                card.innerHTML = `
                    <div class="card-inner">
                        <div class="card-front">
                            <i class="fas fa-code text-3xl md:text-4xl text-green-700 opacity-50"></i>
                        </div>
                        <div class="card-back">${frontContent}</div>
                    </div>
                `;
                card.addEventListener('click', flipGameCard);
                grid.appendChild(card);
            });
        }

        function flipGameCard() {
            if (isMemorizePhase) {
                if (currentDifficulty === 'advanced') {
                    this.classList.toggle('flipped');
                    playSound('flip');
                }
                return; 
            }

            if (lockBoard) return;
            if (this === firstCard) return;
            if (this.classList.contains('matched')) return;

            this.classList.add('flipped');
            playSound('flip');

            if (!hasFlippedCard) {
                hasFlippedCard = true;
                firstCard = this;
                return;
            }

            secondCard = this;
            checkForMatch();
        }

        function checkForMatch() {
            const match1 = firstCard.dataset.id === secondCard.dataset.matchId;
            const match2 = secondCard.dataset.id === firstCard.dataset.matchId;

            if (match1 || match2) {
                disableCards();
            } else {
                unflipCards();
            }
        }

        function disableCards() {
            firstCard.classList.add('matched');
            secondCard.classList.add('matched');
            playSound('match');
            
            if (currentDifficulty === 'advanced') {
                timeLeft += 5;
                let maxTime = 150;
                if(timeLeft > maxTime) timeLeft = maxTime;
                showFloatingText(firstCard, "+5s");
                updateTimerDisplay(timeLeft, maxTime, false);
            }

            matchesFound++;
            resetBoard();

            if (matchesFound === totalPairs) {
                gameOver(true);
            }
        }

        function unflipCards() {
            lockBoard = true;
            playSound('error');
            errorCount++;

            if (currentDifficulty === 'advanced') {
                timeLeft -= 5;
                showFloatingText(firstCard, "-5s", "red");
                updateTimerDisplay(timeLeft, 150, false);
            }
            
            firstCard.classList.add('shake');
            secondCard.classList.add('shake');

            setTimeout(() => {
                firstCard.classList.remove('flipped', 'shake');
                secondCard.classList.remove('flipped', 'shake');
                resetBoard();
            }, 1000);
        }

        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        function showFloatingText(element, text, color = "gold") {
            const rect = element.getBoundingClientRect();
            const float = document.createElement('div');
            float.innerText = text;
            float.style.position = 'fixed';
            float.style.left = rect.left + rect.width/2 + 'px';
            float.style.top = rect.top + 'px';
            float.style.color = color;
            float.style.fontWeight = 'bold';
            float.style.fontSize = '2rem';
            float.style.zIndex = 100;
            float.style.transition = 'all 1s ease-out';
            document.body.appendChild(float);
            requestAnimationFrame(() => {
                float.style.top = (rect.top - 50) + 'px';
                float.style.opacity = 0;
            });
            setTimeout(() => float.remove(), 1000);
        }

        function gameOver(win) {
            clearInterval(timerId);
            clearInterval(memorizeTimerId);
            document.getElementById('bgm').pause();

            if (win) {
                playSound('victory');
                document.getElementById('win-screen').style.display = 'flex';
                startFireworks();
                
                document.getElementById('win-name').innerText = playerName;
                document.getElementById('win-time').innerText = timeLeft + " 秒";
                document.getElementById('win-errors').innerText = errorCount + " 次";
                document.getElementById('win-mode').innerText = currentDifficulty === 'basic' ? '初階任務' : '魔王級關卡';

                let rank = 'C';
                let rankTitle = '新人';
                
                if (currentDifficulty === 'basic') {
                    if (timeLeft >= 80) { rank = 'A'; rankTitle = '資深特工'; }
                    else if (timeLeft >= 40) { rank = 'B'; rankTitle = '特工'; }
                    else { rank = 'C'; rankTitle = '新人'; }
                } else {
                    if (timeLeft >= 100) { rank = 'UR'; rankTitle = '頂尖幹員'; }
                    else if (timeLeft >= 60) { rank = 'SS'; rankTitle = '情報分析師'; }
                    else { rank = 'S'; rankTitle = '臥底'; }
                }

                const rankEl = document.getElementById('win-rank');
                rankEl.innerHTML = `<span class="text-4xl md:text-5xl">${rank}</span><span class="text-base md:text-xl text-white">${rankTitle}</span>`;
                
                if(rank === 'UR') rankEl.style.color = '#d600ff'; 
                else if(rank.includes('S') || rank === 'A') rankEl.style.color = 'gold';
                else if(rank === 'B') rankEl.style.color = '#00ff41';
                else rankEl.style.color = 'white';

                const btnContainer = document.getElementById('win-buttons');
                btnContainer.innerHTML = '';
                
                if (currentDifficulty === 'basic') {
                    btnContainer.innerHTML = `
                         <button onclick="initializeGame('advanced')" class="retro-btn elite w-full animate-pulse">
                            > 進入魔王級關卡
                        </button>
                        <button onclick="location.reload()" class="retro-btn w-full">
                            <i class="fas fa-home"></i> 回首頁
                        </button>
                    `;
                } else {
                    btnContainer.innerHTML = `
                        <button onclick="location.reload()" class="retro-btn w-full">
                            > 任務完成 (RETURN TO HQ)
                        </button>
                    `;
                }
                
            } else {
                playSound('gameover');
                document.getElementById('lose-screen').style.display = 'flex';
                document.getElementById('lose-name').innerText = playerName;
            }
        }

        // Re-challenge logic
        function retryGame() {
            // Stop all sounds and timers
            clearInterval(timerId);
            clearInterval(memorizeTimerId);
            clearInterval(knowledgeTimerId);
            clearInterval(fireworksInterval);
            if(audioCtx) audioCtx.close().then(() => initAudio()); // Reset audio context

            if (currentDifficulty === 'advanced') {
                // Hide Screens
                document.getElementById('lose-screen').style.display = 'none';
                document.getElementById('win-screen').style.display = 'none';
                document.getElementById('game-screen').style.display = 'none';
                document.getElementById('knowledge-screen').style.display = 'none';
                document.getElementById('start-screen').style.display = 'none';
                
                // Play BGM
                const bgm = document.getElementById('bgm');
                bgm.currentTime = 0;
                bgm.play().catch(e => console.log("Audio autoplay blocked"));

                // Show Advanced Intro
                document.getElementById('advanced-intro-screen').style.display = 'flex';
            } else {
                location.reload();
            }
        }

        // --- Fireworks (Reused) ---
        class Firework {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.x = Math.random() * canvas.width;
                this.y = canvas.height;
                this.targetY = Math.random() * (canvas.height / 2);
                this.speed = 5 + Math.random() * 5;
                this.angle = -Math.PI / 2 + (Math.random() * 0.5 - 0.25);
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.particles = [];
                this.exploded = false;
                this.dead = false;
            }
            update() {
                if (!this.exploded) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.1; 
                    if (this.vy >= 0 || this.y <= this.targetY) this.explode();
                } else {
                    this.particles.forEach(p => p.update());
                    this.particles = this.particles.filter(p => p.life > 0);
                    if (this.particles.length === 0) this.dead = true;
                }
            }
            explode() {
                this.exploded = true;
                for (let i = 0; i < 50; i++) this.particles.push(new Particle(this.x, this.y, this.color, this.ctx));
            }
            draw() {
                if (!this.exploded) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.color;
                    this.ctx.fill();
                } else {
                    this.particles.forEach(p => p.draw());
                }
            }
        }
        class Particle {
            constructor(x, y, color, ctx) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.ctx = ctx;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = 0.01 + Math.random() * 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.05;
                this.life -= this.decay;
            }
            draw() {
                this.ctx.globalAlpha = this.life;
                this.ctx.fillStyle = this.color;
                this.ctx.beginPath();
                this.ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.globalAlpha = 1.0;
            }
        }
        function startFireworks() {
            const canvas = document.getElementById('fireworks-canvas');
            const ctx = canvas.getContext('2d');
            let fireworks = [];
            const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
            window.addEventListener('resize', resize);
            resize();
            clearInterval(fireworksInterval);
            fireworksInterval = setInterval(() => {
                if(document.getElementById('win-screen').style.display !== 'flex') return;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (Math.random() < 0.1) fireworks.push(new Firework(canvas, ctx));
                fireworks.forEach(f => f.update());
                fireworks.forEach(f => f.draw());
                fireworks = fireworks.filter(f => !f.dead);
            }, 1000/60);
        }
    </script>
</body>
</html>
