<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF è©¦é¡Œè½‰ Excel/CSV è½‰æ›å™¨</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- SheetJS for Excel Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <script>
        // è¨­å®š PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#2563eb',
                        secondary: '#475569',
                    }
                }
            }
        }
    </script>

    <style>
        body { font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; }
        .drag-active { border-color: #2563eb; background-color: #eff6ff; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const App = () => {
            const [step, setStep] = useState(1); // 1: Upload, 2: Parsing/Edit, 3: Export
            const [rawText, setRawText] = useState("");
            const [parsedData, setParsedData] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [fileName, setFileName] = useState("");
            const [layoutMode, setLayoutMode] = useState("double"); // single or double
            
            const pdfDocRef = useRef(null); // Store parsed PDF doc to allow re-extraction

            // --- PDF Extraction Logic ---
            const extractTextFromPDF = async (pdf, mode) => {
                let fullText = "";
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const viewport = page.getViewport({ scale: 1.0 });
                    const width = viewport.width;
                    
                    // Filter empty items
                    const items = textContent.items.filter(item => item.str.trim().length > 0);
                    
                    // Sorting function: Y desc (Top to Bottom), then X asc (Left to Right)
                    const sortItems = (itemList) => {
                        return itemList.sort((a, b) => {
                            const yDiff = b.transform[5] - a.transform[5]; // Compare Y
                            if (Math.abs(yDiff) > 8) { // Threshold for "same line"
                                return yDiff;
                            }
                            return a.transform[4] - b.transform[4]; // Compare X
                        });
                    };

                    // Stringify function
                    const itemsToString = (itemList) => {
                        let str = "";
                        let lastY = -9999;
                        let lastX = -9999;
                        
                        itemList.forEach(item => {
                            const y = item.transform[5];
                            const x = item.transform[4];
                            
                            if (lastY === -9999) {
                                str += item.str;
                            } else {
                                const yDiff = lastY - y;
                                if (yDiff > 10) { // New line
                                    str += "\n" + item.str;
                                } else {
                                    // Same line: Add space if gap is reasonable
                                    // (Simple approach: always add space for safety in exam parsing)
                                    str += " " + item.str;
                                }
                            }
                            lastY = y;
                            lastX = x; // Not used for now but good for advanced logic
                        });
                        return str;
                    };

                    if (mode === 'double') {
                        // Double Column Strategy: Split page in half
                        const midX = width / 2;
                        const leftCol = items.filter(item => item.transform[4] < midX);
                        const rightCol = items.filter(item => item.transform[4] >= midX);
                        
                        const sortedLeft = sortItems(leftCol);
                        const sortedRight = sortItems(rightCol);
                        
                        fullText += itemsToString(sortedLeft) + "\n" + itemsToString(sortedRight) + "\n\n";
                    } else {
                        // Single Column Strategy: Sort full page
                        const sortedItems = sortItems(items);
                        fullText += itemsToString(sortedItems) + "\n\n";
                    }
                }
                return fullText;
            };

            const processPDF = async (pdf, mode) => {
                setIsProcessing(true);
                try {
                    const text = await extractTextFromPDF(pdf, mode);
                    setRawText(text);
                    setStep(2);
                    autoParse(text);
                } catch (error) {
                    console.error(error);
                    alert("è§£æ PDF æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚");
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                if (file.type !== 'application/pdf') {
                    alert('è«‹ä¸Šå‚³ PDF æª”æ¡ˆ');
                    return;
                }

                setFileName(file.name.replace('.pdf', ''));
                setIsProcessing(true);
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    pdfDocRef.current = pdf; // Save ref
                    await processPDF(pdf, layoutMode);
                } catch (error) {
                    console.error(error);
                    alert("è®€å– PDF å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæœªåŠ å¯†ä¸”åŒ…å«å¯é¸å–æ–‡å­—ã€‚");
                    setIsProcessing(false);
                }
            };

            const handleLayoutChange = async (newMode) => {
                setLayoutMode(newMode);
                if (pdfDocRef.current) {
                    await processPDF(pdfDocRef.current, newMode);
                }
            };

            // --- Parsing Logic (Heuristic for Exams) ---
            const autoParse = (text) => {
                // Pre-cleaning
                let cleanText = text.replace(/--- PAGE \d+ ---/g, ""); // Remove page numbers if common pattern
                
                const questions = [];
                
                // Strategy: Find patterns like "1.", "2.", "3." followed by text
                // We split the text by these markers.
                // Regex: newline followed by number and dot/parenthesis
                // Note: This is tricky. Let's try to identify start positions.
                
                const qRegex = /\n(\d+)[\.ï¼ã€\)]/g;
                let match;
                let indices = [];
                
                while ((match = qRegex.exec(cleanText)) !== null) {
                    indices.push({ index: match.index, num: match[1] });
                }

                if (indices.length === 0) {
                    // Fallback: Try looking for just numbers at start of lines if file is clean
                    const simpleRegex = /^(\d+)[\.ï¼ã€\)]/gm;
                    while ((match = simpleRegex.exec(cleanText)) !== null) {
                         indices.push({ index: match.index, num: match[1] });
                    }
                }

                if (indices.length === 0) {
                    // No structure found, just put all text in one row
                    setParsedData([{ num: '?', question: cleanText.substring(0, 500) + '...', a:'',b:'',c:'',d:'', ans:'', exp:'' }]);
                    return;
                }

                for (let i = 0; i < indices.length; i++) {
                    const start = indices[i].index;
                    const end = (i + 1 < indices.length) ? indices[i+1].index : cleanText.length;
                    let block = cleanText.substring(start, end).trim();
                    
                    let item = {
                        id: i,
                        num: indices[i].num,
                        question: "",
                        a: "", b: "", c: "", d: "",
                        ans: "",
                        exp: ""
                    };

                    // Extract Answer (Common formats: ã€Šç­”æ¡ˆã€‹A, Ans: A, (A))
                    const ansMatch = block.match(/(ã€Šç­”æ¡ˆã€‹|ç­”æ¡ˆï¼š|Ans:|ANSWER:)\s*([A-DE])/i);
                    if (ansMatch) {
                        item.ans = ansMatch[2].toUpperCase();
                        block = block.replace(ansMatch[0], ""); 
                    }

                    // Extract Explanation
                    const expMatch = block.match(/(è©³è§£:|è©³è§£ï¼š)([\s\S]*)/);
                    if (expMatch) {
                        item.exp = expMatch[2].replace(/\n/g, "").trim();
                        block = block.replace(expMatch[0], "");
                    }

                    // Remove question number from text
                    block = block.replace(new RegExp(`^${item.num}[\.ï¼ã€\)]`), "").trim();

                    // Extract Options
                    // Patterns: (A)... (B)... or A.... B.... or A. ... B. ...
                    // We look for the last occurrence of these markers to split
                    
                    // Normalize option markers to (A) style for easier splitting if they are A. or [A]
                    // (This is a simplified approach, real world is messy)
                    
                    const optA_idx = block.search(/\(A\)|\[A\]|^A[\.ï¼]/m);
                    const optB_idx = block.search(/\(B\)|\[B\]|^B[\.ï¼]/m); // search needs improvement for mid-text
                    
                    // Simple index finding for standard (A) (B) (C) (D)
                    let idxA = block.indexOf("(A)");
                    let idxB = block.indexOf("(B)");
                    let idxC = block.indexOf("(C)");
                    let idxD = block.indexOf("(D)");

                    // Fallback for A. B. C. D.
                    if (idxA === -1) idxA = block.indexOf("A.");
                    if (idxB === -1) idxB = block.indexOf("B.");
                    if (idxC === -1) idxC = block.indexOf("C.");
                    if (idxD === -1) idxD = block.indexOf("D.");

                    if (idxA !== -1 && idxB !== -1 && idxC !== -1 && idxD !== -1) {
                        item.question = block.substring(0, idxA).trim();
                        item.a = block.substring(idxA, idxB).replace(/^[\(ï¼ˆ]?[A-D][\)ï¼‰\.ï¼]/, "").trim();
                        item.b = block.substring(idxB, idxC).replace(/^[\(ï¼ˆ]?[A-D][\)ï¼‰\.ï¼]/, "").trim();
                        item.c = block.substring(idxC, idxD).replace(/^[\(ï¼ˆ]?[A-D][\)ï¼‰\.ï¼]/, "").trim();
                        item.d = block.substring(idxD).replace(/^[\(ï¼ˆ]?[A-D][\)ï¼‰\.ï¼]/, "").trim();
                    } else {
                        item.question = block;
                    }

                    questions.push(item);
                }

                setParsedData(questions);
            };

            // --- Export Logic ---
            const exportExcel = () => {
                const worksheet = XLSX.utils.json_to_sheet(parsedData.map(row => ({
                    "é¡Œè™Ÿ": row.num,
                    "é¡Œç›®": row.question,
                    "é¸é …A": row.a,
                    "é¸é …B": row.b,
                    "é¸é …C": row.c,
                    "é¸é …D": row.d,
                    "ç­”æ¡ˆ": row.ans,
                    "è©³è§£": row.exp
                })));
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "è©¦é¡Œ");
                XLSX.writeFile(workbook, `${fileName}_converted.xlsx`);
            };

            const exportCSV = () => {
                // Manual CSV construction to ensure compatibility
                let csvContent = "\uFEFF"; // BOM
                csvContent += "é¡Œè™Ÿ,é¡Œç›®,é¸é …A,é¸é …B,é¸é …C,é¸é …D,ç­”æ¡ˆ,è©³è§£\n";
                
                parsedData.forEach(row => {
                    const fields = [
                        row.num, row.question, row.a, row.b, row.c, row.d, row.ans, row.exp
                    ];
                    const escapedFields = fields.map(field => {
                        const str = String(field || "");
                        if (str.includes('"') || str.includes(',') || str.includes('\n')) {
                            return `"${str.replace(/"/g, '""')}"`;
                        }
                        return str;
                    });
                    csvContent += escapedFields.join(",") + "\n";
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = `${fileName}_converted.csv`;
                document.body.appendChild(link);
                link.click();
            };

            // --- UI Components ---
            
            // Step 1: Upload
            if (step === 1) {
                return (
                    <div className="flex flex-col items-center justify-center min-h-screen p-4">
                        <div className="bg-white p-8 rounded-xl shadow-xl max-w-lg w-full text-center">
                            <div className="mb-6 flex justify-center text-blue-600">
                                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3 3 3-3"/></svg>
                            </div>
                            <h1 className="text-2xl font-bold mb-2 text-gray-800">PDF è©¦é¡Œè½‰ Excel è½‰æ›å™¨</h1>
                            <p className="text-gray-500 mb-6">ä¸Šå‚³æ‚¨çš„ PDF è©¦é¡Œå·ï¼Œè‡ªå‹•è§£æé¡Œç›®ã€é¸é …èˆ‡ç­”æ¡ˆã€‚</p>
                            
                             <div className="mb-6 flex justify-center">
                                <div className="bg-gray-100 p-1 rounded-lg flex text-sm">
                                    <button 
                                        onClick={() => setLayoutMode('single')}
                                        className={`px-4 py-1.5 rounded-md transition ${layoutMode === 'single' ? 'bg-white shadow text-blue-600 font-bold' : 'text-gray-500 hover:text-gray-700'}`}
                                    >
                                        å–®æ¬„æ–‡ä»¶
                                    </button>
                                    <button 
                                        onClick={() => setLayoutMode('double')}
                                        className={`px-4 py-1.5 rounded-md transition ${layoutMode === 'double' ? 'bg-white shadow text-blue-600 font-bold' : 'text-gray-500 hover:text-gray-700'}`}
                                    >
                                        é›™æ¬„è©¦å· (é è¨­)
                                    </button>
                                </div>
                            </div>

                            {isProcessing ? (
                                <div className="flex flex-col items-center">
                                    <div className="loader mb-4"></div>
                                    <p className="text-gray-600">æ­£åœ¨è®€å– PDF æ–‡å­—ï¼Œè«‹ç¨å€™...</p>
                                </div>
                            ) : (
                                <label className="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50 hover:border-blue-500 transition">
                                    <div className="flex flex-col items-center justify-center pt-5 pb-6">
                                        <p className="mb-2 text-sm text-gray-500"><span className="font-semibold">é»æ“Šä¸Šå‚³</span> æˆ–æ‹–æ”¾æª”æ¡ˆ</p>
                                        <p className="text-xs text-gray-500">åƒ…æ”¯æ´ PDF æª”æ¡ˆ (æ–‡å­—å‹)</p>
                                    </div>
                                    <input type="file" className="hidden" accept=".pdf" onChange={handleFileUpload} />
                                </label>
                            )}
                            
                            <div className="mt-6 text-xs text-gray-400 text-left bg-gray-50 p-3 rounded">
                                <p className="font-bold mb-1">ğŸ’¡ å°æé†’ï¼š</p>
                                <ul className="list-disc pl-4 space-y-1">
                                    <li>æª”æ¡ˆå¿…é ˆæ˜¯ã€Œæ–‡å­—å¯é¸å–ã€çš„ PDFï¼ˆéç´”åœ–ç‰‡æƒæï¼‰ã€‚</li>
                                    <li>è‹¥ä¸Šå‚³å¾Œé †åºéŒ¯äº‚ï¼Œè«‹å˜—è©¦åˆ‡æ›ã€Œå–®/é›™æ¬„ã€æ¨¡å¼ã€‚</li>
                                    <li>æ‰€æœ‰è™•ç†çš†åœ¨ç€è¦½å™¨ç«¯å®Œæˆï¼Œæª”æ¡ˆä¸æœƒä¸Šå‚³è‡³ä¼ºæœå™¨ã€‚</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                );
            }

            // Step 2: Editor
            return (
                <div className="flex flex-col h-screen">
                    {/* Header */}
                    <header className="bg-white border-b p-4 flex flex-col md:flex-row justify-between items-center shadow-sm z-10 gap-4">
                        <div className="flex items-center gap-3 w-full md:w-auto">
                            <button onClick={() => setStep(1)} className="text-gray-500 hover:text-gray-700">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 12H5m7 7-7-7 7-7"/></svg>
                            </button>
                            <div>
                                <h1 className="font-bold text-lg text-gray-800 line-clamp-1">{fileName}</h1>
                                <div className="flex items-center gap-2 mt-1">
                                    <span className="bg-blue-100 text-blue-800 text-xs px-2 py-0.5 rounded-full">å…±è§£æå‡º {parsedData.length} é¡Œ</span>
                                    
                                    {/* Quick Layout Switcher in Editor */}
                                    <select 
                                        value={layoutMode} 
                                        onChange={(e) => handleLayoutChange(e.target.value)}
                                        className="text-xs border-gray-300 rounded bg-gray-50 text-gray-600 py-0.5 px-1 focus:ring-blue-500 focus:border-blue-500"
                                    >
                                        <option value="double">é›™æ¬„æ¨¡å¼</option>
                                        <option value="single">å–®æ¬„æ¨¡å¼</option>
                                    </select>
                                    {isProcessing && <span className="text-xs text-blue-600 animate-pulse">é‡æ–°è§£æä¸­...</span>}
                                </div>
                            </div>
                        </div>
                        <div className="flex gap-2 w-full md:w-auto justify-end">
                             <button onClick={() => {
                                 const newText = prompt("å¦‚æœè§£æä¸å®Œæ•´ï¼Œè«‹æ‰‹å‹•è²¼ä¸Šæ–‡å­—é‡æ–°è§£æï¼š", rawText);
                                 if(newText) {
                                     setRawText(newText);
                                     autoParse(newText);
                                 }
                             }} className="text-sm text-gray-600 px-3 py-2 hover:bg-gray-100 rounded whitespace-nowrap">
                                 æŸ¥çœ‹/ä¿®æ”¹æ–‡å­—
                             </button>
                             <div className="hidden md:block h-6 w-px bg-gray-300 mx-1"></div>
                             <button onClick={exportCSV} className="flex items-center gap-2 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition shadow whitespace-nowrap">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                                <span className="hidden sm:inline">ä¸‹è¼‰</span> CSV
                             </button>
                             <button onClick={exportExcel} className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition shadow whitespace-nowrap">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h8"/><path d="M8 17h8"/><path d="M10 9h4"/></svg>
                                <span className="hidden sm:inline">ä¸‹è¼‰</span> Excel
                             </button>
                        </div>
                    </header>

                    {/* Main Content */}
                    <main className="flex-1 overflow-auto bg-gray-50 p-4">
                        <div className="max-w-7xl mx-auto bg-white shadow rounded-lg overflow-hidden">
                            <div className="overflow-x-auto">
                                <table className="min-w-full divide-y divide-gray-200">
                                    <thead className="bg-gray-50">
                                        <tr>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase w-12">#</th>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase w-1/3">é¡Œç›®</th>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase">é¸é … A</th>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase">é¸é … B</th>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase">é¸é … C</th>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase">é¸é … D</th>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase w-16">ç­”æ¡ˆ</th>
                                            <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase w-1/6">è©³è§£</th>
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-gray-200 text-sm">
                                        {parsedData.map((row, index) => (
                                            <tr key={index} className="hover:bg-gray-50">
                                                <td className="px-3 py-2 text-gray-500">{row.num}</td>
                                                <td className="px-3 py-2">
                                                    <textarea 
                                                        className="w-full border-gray-200 rounded focus:ring-blue-500 focus:border-blue-500 text-sm"
                                                        rows="2"
                                                        value={row.question}
                                                        onChange={(e) => {
                                                            const newData = [...parsedData];
                                                            newData[index].question = e.target.value;
                                                            setParsedData(newData);
                                                        }}
                                                    />
                                                </td>
                                                {['a','b','c','d'].map(opt => (
                                                    <td key={opt} className="px-2 py-2">
                                                        <input 
                                                            type="text" 
                                                            className="w-full border-gray-200 rounded focus:ring-blue-500 focus:border-blue-500 text-sm"
                                                            value={row[opt]}
                                                            onChange={(e) => {
                                                                const newData = [...parsedData];
                                                                newData[index][opt] = e.target.value;
                                                                setParsedData(newData);
                                                            }}
                                                        />
                                                    </td>
                                                ))}
                                                <td className="px-2 py-2">
                                                     <input 
                                                            type="text" 
                                                            className="w-full border-gray-200 rounded text-center font-bold text-green-600 focus:ring-blue-500 focus:border-blue-500"
                                                            value={row.ans}
                                                            onChange={(e) => {
                                                                const newData = [...parsedData];
                                                                newData[index].ans = e.target.value;
                                                                setParsedData(newData);
                                                            }}
                                                        />
                                                </td>
                                                <td className="px-3 py-2">
                                                    <textarea 
                                                        className="w-full border-gray-200 rounded focus:ring-blue-500 focus:border-blue-500 text-xs text-gray-600"
                                                        rows="2"
                                                        value={row.exp}
                                                        onChange={(e) => {
                                                            const newData = [...parsedData];
                                                            newData[index].exp = e.target.value;
                                                            setParsedData(newData);
                                                        }}
                                                    />
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                            
                            {parsedData.length === 0 && (
                                <div className="p-8 text-center text-gray-500">
                                    <p>ç„¡æ³•è‡ªå‹•è­˜åˆ¥é¡Œç›®æ ¼å¼ã€‚</p>
                                    <p className="text-sm mt-2">è«‹å˜—è©¦é»æ“Šä¸Šæ–¹ã€ŒæŸ¥çœ‹/ä¿®æ”¹åŸå§‹æ–‡å­—ã€ç¢ºèª PDF æ–‡å­—æ˜¯å¦æ­£å¸¸ã€‚</p>
                                </div>
                            )}
                        </div>
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>